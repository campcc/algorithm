**客户端渲染 & 服务端渲染**

SSR 原理：浏览器请求内容时，服务端直接组装好 HTML 文本返回浏览器进行渲染，渲染流程中，DOM 树构建阶段省去了 JavaScript 脚本的解析

SSR 优势，

1. HTML 无需等到所有 JavaScript 都下载执行完即可显示，用户可以更快看到页面，对于首屏加载速度与转化率相关的应用而言，尤为重要
2. 对 SEO 友好，如果应用以 loading 开始通过 Ajax 获取内容，爬虫并不会等到内容加载完成后再抓取

一些限制，

1. 开发限制：浏览器端特定代码只能在某些生命周期中使用，需要考虑服务端能否支持
2. 构建配置较为复杂：SSR 需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意静态文件服务器上
3. 更高的服务端负载：因为存在 Node 端，需要考虑服务器负债，合理的缓存策略

一些考量，

1. SSR 更适用于首屏或关键页面，而不是所有页面，服务端负载过大，Web 服务器的响应时间可能会抵消掉 SSR 带来的页面加载速度的优势
2. 尽量使用统一的心智模型，相同的语言来开发整个应用，避免后端模板系统到前端框架的切换，目前主流的框架基本都提供了 SSR 方案

**CSR 客户端渲染**

CSR 原理：浏览器请求内容时，服务器返回简单的 HTML，以及 JavaScript、CSS 等文件链接，由浏览器下载执行脚本进行渲染

完整的渲染流程：DOM 树构建，样式计算，布局，分层，图层绘制，栅格化，合成

**DOM 树构建**

构建流程：网络进程，渲染进程，管道，HTML 解析器，Token 栈

1. HTML 解析器暂停解析？脚本和样式阻塞
2. 如何规避或优化 DOM 树构建阻塞？预解析、CDN 加速、压缩、script 后置、async、defer
3. async 和 defer 区别？都是异步加载，区别在执行时机上，async 下载完立即执行，defer 会在 DOMContentLoaded 事件前执行

**样式计算**

流程：构建 StyleSheets，属性值标准化，计算节点样式

1. 渲染引擎无法理解 CSS，需要将 CSS 转换为 StyleSheets，一颗支持查询和修改的样式树
2. 属性值标准化：rem、bold、black 等单位和关键字转换
3. 计算节点样式的过程？通过 CSS 的层叠规则和继承规则，计算 DOM 节点每个元素的具体样式，生成 ComputedStyle
4. 解释下 Cascade？不同规则应用于同一个元素时，会产生冲突，Cascade 定义了如何合并多个来自不同源的 CSS 声明
5. 层叠样式的优先级是什么样的？内联样式 > style 标签 > link 引用的外部 CSS>浏览器默认的 UserAgent
6. 解释下继承 Inheritance？一些 CSS 属性会默认继承其父元素的值，如字体大小，颜色等，具体哪些没必要死记，想象一下 border 如果能继承有多糟糕

**布局**

为什么需要布局？构建好的 DOM 树中包含一些特殊节点，比如 head 标签，display 为 none 的元素，它们是不需要被渲染的，所以我们需要根据 DOM 树额外构建一颗只包含可见元素的布局树

1. 布局阶段做了什么？创建只包含可见元素的布局树，进行节点几何坐标位置的计算

**分层**

关键词：图层，层叠上下文

有了布局树后还不能开始绘制，因为页面往往还包含 3D 变换、页面滚动、层叠上下文的 Z 轴排序等复杂效果，需要进行分层

1. 什么是分层？将布局树转换为图层树，图层和 PS，Sketch 等设计软件中的图层概念类似
2. 页面与图层的关系？打开浏览器的 Layout 标签，可以看到页面被分成了很多图层，图层叠加形成了最终的页面
3. 什么时候会创建图层？拥有层叠上下文属性、需要被裁剪的区域、滚动条
4. 什么是层叠上下文？视觉格式化模型中，BFC、IFC、FFC 等定义了盒子在二维文档流中的布局方式，而层叠上下文是对 HTML 元素的一个三位构想，定义了元素在 Z 轴上的排列方式
5. 层叠规则？z 轴上按层叠等级进行层叠，具有层叠上下文的元素优先于普通元素，同一层叠上下文中，通过设置 z-index 调整层叠顺序，等级相同按文档流中出现的顺序
6. 哪些元素会创建层叠上下文？
   （1） 文档根元素
   （2） position 为 absolute 或 relative 且 z-index 不为 auto
   （3） position 为 fixed 或 sticky
   （4） flex 或 grid 容器中 z-index 不为 auto 的子元素
   （5） opacity 值小于 1
   （6） transform、filter、clip-path、perspective 不为 none
   （7） will-change 设定了任一属性
7. 什么是裁剪？内容超出包含块就会发生裁剪，渲染引擎会为原始内容单独创建一个图层

**图层绘制**

流程：遍历 LayoutTree 为每个图层生成绘制指令列表

**栅格化**

绘制指令列表准备好后，主线程会把列表提交给合成线程，然后执行栅格化

1. 为什么需要提交到另一个线程绘制？为了加速图层绘制过程，合成线程接受到绘制指令后就可以开始栅格化，无需等待主线程把完成的绘制指令全部生成
2. 什么是栅格化？图层划分为图块，然后将图块转换为位图的过程
3. 为什么需要转换位位图？直接绘制图层不行吗？首先视口代表屏幕上的可视区域，通常情况下合成线程接受到的图层都是大于视口的，为了提高渲染效率，没有必要将整个图层全部绘制，而是优先保证视口及附近的位图
4. 知道快速栅格化吗？快速栅格化就是通过 GPU 来加速生成位图

**合成**

栅格化完成后，生成绘制图块的命令，然后提交给 GPU 完成绘制

**重排 & 重绘**

1. 什么是重排？修改了 DOM 元素的几何位置属性后，导致浏览器触发布局、分层、绘制、栅格化等一系列完整的渲染流程
2. 什么是重绘？修改了 DOM 元素样式导致的渲染流程，与重排相比会跳过布局和分层阶段
3. 哪些情况下会导致 ReFlow？改变盒子模型相关的属性、位置属性；DOM 节点的增减、移动；获取偏移量、滚动量等计算属性值
4. 为什么获取计算属性值会导致 ReFlow？布局计算是通过队列机制来批量进行的，获取计算属性时，队列中科恩那个存在影响属性的操作，为了保证计算属性值的正确性，浏览器会清空队列来确保返回正确值
5. 修改 transform 和 opacity 会触发重排和重绘吗？不会，这两个值会跳过布局和绘制等阶段，只执行后续的合成操作，由于合成在非主线程中进行，效率会高很多

针对渲染流程的一些优化，

1. 减少重绘和重排
2. transform 替代 top
3. visibility 替代 display none
4. 动画效果应用到 position 为 absolute 或 fixed 的元素，避免影响其他元素布局
5. 避免设置多层内联样式，CSS 查找从右向左
6. 避免使用不稳定的布局如 table，避免 CSS 表达式，表达式可能会引发重排
