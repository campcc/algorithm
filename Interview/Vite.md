### Vite

什么是 Vite？在尤雨溪开发 Vue3.0 时诞生的一个前端构建工具，可以理解为：webpack + webpack-dev-server

Vite 具有如下特点：

1. 快速冷启动：No Boundle + esbuild 预构建
2. 即时的模块热更新：基于 ESM 的 HMR，同时利用浏览器缓存策略提升速度
3. 真正的按需加载：利用浏览器对 ESM 的支持，实现真正的按需加载

**vs Webpack，Snowpack**

Webpack 是目前使用量最大，社区最完善的打包工具，其构建原理是，

启动时，从一个入口文件开始，进行依赖分析，构建项目模块的依赖图；如果改动了代码，Webpack 会对相关的依赖重新打包，所以随着项目变大，其打包的速度也会下降

而 Vite 没有打包的过程，而是直接启动了一个 Koa 服务器，劫持了浏览器的 HTTP 请求，在后端进行相应的处理，再返回给浏览器，整个过程没有对文件进行打包编译，所以会快很多

Snowpack 是首次提出并利用浏览器原生的 ESM 能力的打包工具，但是它的构建，用什么工具是交给用户自己去选择的，整个的打包体验有点支离破碎，

而 Vite 整合了 Rollup，为用户提供了完整的，开箱即用的解决方案，所以二者最大的区别是在需要打包 boundle 的时候，Vite 使用 Rollup 内置配置，Snowpack 则通过插件委托给了其他的打包工具

**Vite 原理**

要理解 Vite 的原理，需要先了解 ESM 、esbuild、Rollup 这几个概念

**ESM**

ESM 是 JavaScript 提出的官方标准化的模块系统，不同于之前 CJS（Common JS），AMD，CMD 的模块方案，ESM 提供了更原生更动态的模块加载方案，最重要的一点是它是浏览器原生支持的，

也就是说，我们可以直接在浏览器执行 import 语句，动态导入模块，

```html
<script type="module">
  import moduleA from "xxx";
</script>
```

截止目前，在 caniuse 上我们可以发现，大约 92% 的浏览器 ESM，而且作为 ECMA 标准，未来会有更多的浏览器支持 ECMA 规范

那 ESM 的执行过程是什么样的呢？

我们知道，当我们使用模块进行开发时，其实就是在构建一张模块依赖图，当模块加载时，就会从入口文件开始最终生成完整的模块实例图，ESM 本质也是这样，具体来说 ESM 在执行时有三个步骤，

1. 构建：确定从哪里下载模块文件，下载并将所有文件解析为模块记录
2. 实例化：将模块记录转换为模块实例，为其分配内存空间，然后依据导入、导出语句将模块指向对应的内存地址
3. 运行：运行代码，将内存空间填充

所以， ESM 使用的是实时绑定的模式，导入和导出的模块都指向同一个内存地址，也就是值引用；而像 CJS 这样的模块系统使用的是值的拷贝，即所有导出值都是拷贝值

**esbuild**

Vite 的底层使用的是 esbuild 来实现对 tx, jsx 这样的文件的转换，什么是 esbuild？

esbuild 是一个 JavaScript bundle 打包和压缩工具，类似于 Webpack、Rollup，它最大的一个特点就是快，为什么快？两个原因，

1. 首次，大多数的打包工具都是基于 JavaScript 实现，而 esbuild 使用 go 语言实现；JavaScript 是解释型语言，边运行边解释，但 go 可以在编译的时候就转换为机器语言，启动时直接执行，性能更高
2. 其次，JavaScript 是单线程语言，直到引入 WebWorker 后才支持在浏览器、Node 中执行多线程操作，而且 webpack 源码中其实也并未使用 Webworker 提供的多线程能力，但是 go 语言天生支持多线程

**Rollup**

与 Webpack 使用 CJS 模块（运行时加载）不同，Rollup 是一个基于 ESM 的打包工具，所以它能打包出更小、更快的包，为什么？

Rollup 是最早实现 Tree-Shaking 的模块打包器，因为这个概念就是作者 Rich Harris 在 2015 年首次提出的，Tree-Shaking 的实现是基于 ESM 的，

Tree-Shaking 的原理是，

利用 ESM 在编译阶段可以对模块进行静态分析的能力，找到 Dead Code，打上标记， 然后在压缩阶段利用像 uglify-js 这样的压缩工具进行消除，

后来 Webpack 也在其 2.x 版本中引入了 ESM 模块支持了树摇

**Vite 的核心原理**

在 Vite 和 Snowpack 之前，传统的打包工具如 Webpack 是先解析依赖，然后打包构建再启动服务器，Dev Server 必须要等待所有模块构建完成再启动；而修改了 bundle 中的一个子模块时，整个 bundle 文件都会被重新打包，所以导致了项目越大，模块越多，启动时间越长，

Vite 不同，Vite 利用浏览器对 ESM 的支持，先启动 Dev Server，拦截浏览器请求，具体来说，

1. 当声明一个 script 标签类型为 module ，浏览器解析资源时，会向当前域名发起一个 GET 请求
2. Vite 启动一个 Koa 服务器拦截这些请求
3. 在服务器端对请求文件进行分类处理，转换为 ESM 格式返回给浏览器

所以加载模块时本质上只请求了该模块对应的文件，实现了真正意义上的按需加载，即使项目变大，其构建速度也不会受影响

**Vite 热更新 HMR 原理**

目前所有的打包工具实现热更新的大体思路都大同小异：

通过 WebSocket 创建一个浏览器和 Dev Server 的长连接，然后服务端监听文件的改变，当文件被修改时，向浏览器推送消息，浏览器对不同的文件操作进行更新

与 webpack 需要进行重新编译，再请求变更后的模块代码重新加载不同，Vite 不需要重新编译，具体来说，Vite 的热更新流程可以分为四步，

1. 启动 dev server，创建 WebSocket 连接
2. 通过一个库启动文件监听
3. 代码变更时，生成文件变更信息推送到浏览器
4. 浏览器获取更新文件执行更新

此外，Vite 还利用了浏览器的缓存策略加速页面的响应，比如，

1. 依赖模块设置响应头对其进行强缓存
2. 源码文件状态码返回 304，减少不必要的数据传输
