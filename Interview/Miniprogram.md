**小程序自动埋点方案**

1. 原理：重写 Component 和 Page 构造器，通过页面路径 + 事件名 + 参数可以唯一确定一个埋点
2. 2 种接入方式：集成到 Ration | 提供单独覆盖包（提供注入，手动，配置）
3. 覆盖场景：生命周期、自定义函数、页面事件函数
4. 对于参数：1.页面绑定事件函数可以直接拿到 event.dataset 自动上报，结合配置映射可以自定义上报参数名称

**Javascript 浮点数精度问题**

所有使用 IEEE754 标准（二进制浮点数算术标准）来表示整数和浮点数的语言都有类似问题

本质是 ECMAScript 浮点数存储导致，

```js
Value = sign * exponent * fraction;
```

类似于科学计数法，比如 -1020 表示为 -1 _ 10^3 _ 1.02, IEEE754 用 64 位存储一个浮点数，其中，

1. 符号位 sign 占 1 位
2. 指数位 exponent 占 11 位
3. 分数位 fraction 占 52 位

部分浮点数如 0.1 转换为二进制后是一个无限循环数，所以在存储时 fraction 就已经有误差了

浮点数运算原理：对阶（小阶对大阶）、尾数运算（加减乘除）、规格化（将对阶后结果再转换回去）、舍入处理、溢出判断

1. 解决思路：将浮点数转换为整数进行计算
1. JavaScript 数值表示：十进制(36), 十六进制(0x1), 科学计数法(123e+3, 0.123e-3)，需要考虑科学计数法表示的场景
1. strip: 将数值尝试转换为固定精度的浮点数
1. digitLength: 获取数值的小数长度，需要考虑科学计数法的 e-x 的场景
1. float2Fixed: 将浮点数转换为整数，去除小数位
1. 乘除法运算思路: 将操作数转换为整数进行运算，再转换为浮点数；两个小数相乘，结果的小数位为两个操作数的小数位之和
1. 加减法运算思路：计算两个操作数最大的小数位，利用乘法转换为最大小数位的整数，相加后再除以转换倍数，其中除法 需要注意的是，小数位差值的倍数可能为不精确小数，考虑用 strip 进行修正

**Ration**

1. 高阶函数或类返回 Page、App
2. 支持 injection 注入一些常用方法
3. 防抖和节流支持快捷调用方式，Page 的 init 初始化，onLoad 里进行扩展
4. 整合 underscore
5. 提供封装好的请求方法
6. 整合自动埋点

**惯性滚动**

IOS 系统的 Safari 浏览器最早支持 -webkit-overflow-scrolling: touch，但存在兼容性问题

建模：滑块模型（带弹簧）

1. 惯性滚动第一阶段，匀加速计算初始速度
2. 惯性滚动第二阶段，匀减速计算滚动距离和时长
3. 需要考虑触发条件，停留时长小于某个阈值且最小位移距离大于某个阈值
4. 惯性滚动一般发生在容器内，需要考虑回弹
5. 惯性滚动第三阶段，滑块受反向的摩擦力和弹簧拉力做变减速运动，加速度越来越大，可以用一个近似的缓动曲线去描述这一过程，需要计算滑块触碰边界后的滚动距离，也就是曲线在时间范围内与 x 轴围成的面积，可以用积分表示，我们刚开始使用了 ease-out，因为我们知道该曲线的一个函数，可以很方便的计算其原函数，代入牛顿莱布利兹公式，就可以计算出积分值，也就是我们的滚动距离，但实际场景下 ease-out 的缓动效果比较差，我们不断地调整贝塞尔曲线，进行了大量地缓动效果测试，最终确认了缓动曲线，但是要计算该曲线的原函数是很复杂的，我们考虑将模型再一次进行了简化，由于第三阶段的加速度是大于匀减速运动的加速度的，所以第三阶段滑块触碰到边界后的滚动距离一定小于匀减速运动情况下的滚动距离，所以我们不妨设置一个阻力常量将不等式转化，最后在当前的贝塞尔曲线下经过大量的测试，这里的阻力常量设置为 10 - 12 较为合适
6. 最后还需要对惯性滚动的各个阶段设置缓动曲线，这里不涉及计算，只有大量的测试
7. 还有一个问题是处于回弹过程用户再次触碰元素时，我们需要暂停缓动，这里不同平台做法有些差异，在小程序端我们需要通过 getComputedStyle 获取当前元素的计算样式值，然后对偏移量进行重设

**多行省略**

1. 单行省略的方案是统一的，没有太多魔法
2. 最简单的多行省略是通过 CSS 属性 -webkit-line-clamp，移动端友好，PC 需要关注下兼容性，不支持自定义省略样式
3. 浮动实现，三个盒子文字，占位和自定义样式的省略盒子，全部向右浮动，然后给文字盒负边距值刚好为占位盒宽度，这样一来就给了占位盒子空间，当文字盒高度小于占位盒的时候，自定义省略盒子只能在第二排，但是当文字盒高度大于占位盒的时候，第一排的就有了多余空间，省略盒子就能挤进去，这时我们只需要将省略盒子定位到和占位盒同排就好了，这里可以使用 transform，最后在修饰一下给省略盒子增加文字颜色和渐变，这里其实利用了浮动和 BFC 原理，浮动盒子的区域不会和 BFC 重叠，在计算 BFC 高度时，浮动元素也会参与计算，浮动方案优点，支持所有主流浏览器，支持自定义带渐变的文字省略样式，对于背景颜色复杂的区域或者自定义省略样式需求时力不从心
4. 浮动 + line-clamp，借助 line-clamp 默认的省略号进行占位，隐藏省略号，替换为自定义省略盒子，预留位置可以调整字号，但是 font-size 会继承，所以需要再内嵌一个子盒子重置字号，隐藏省略号，可以通过设置透明度或颜色，接着通过浮动将自定义省略盒子定位到预留位置，但是由于设置了 line-clamp 会导致文字盒子无法撑开完整的高度，为了使用浮动的方案我们可以多渲染一份一模一样的文案来撑开高度，设置颜色透明

**原子 CSS**

1. 传统方案，Tailwind CSS，利用 CSS 预处理器比如 Sass 语法批量生成原子 CSS，生产环境使用 PurgeCSS 扫描打包产物删除不需要的规则
2. 存在什么问题？开发环境需要使用包含了所有规则额巨大 CSS 文件，这在 webpack 中表现不明显，但是在 snowpack、vite 这样的构建工具下有很大影响，毕竟其他内容的加载都非常快速
3. 调换生成和扫描的顺序就是 Windi CSS，先扫描源码，将文件内容传递给原子生成器配对 class 的使用情况，生成原子 CSS 再启动服务器，HMR 原理类似，通常会启动一个文件系统监听器比如 chokidar，文件改变时将新的内容传递给生成器，清除 CSS 缓存并触发 HMR 事件
4. 理论上 Windi CSS 已经是比较完美的解决方案了，但是由于要与 Tailwind 兼容，存在历史包袱，定制化功能有限，所以诞生了 UnoCSS
5. UnoCSS 在实现上则是跳过了解析，与 Tailwind 依赖于 PostCSS 的 AST 进行修改，Windi 自己编写了一个自定义解析器和 AST 不同，UnoCSS 通过高效的字符串拼接和正则匹配生成按需的 CSS，没有引入编译过程，加上对类名和生成的 CSS 字符串进行缓存，性能再一次提高
6. 如何解决原子和模块 CSS 冲突？模块 CSS 使用固定前缀 + 哈希混入的方式，在生成原子 CSS 的时候跳过

其他一些考量，

1. 基于原子 CSS 生成 VsCode 代码片段，工具已支持
2. 低代码自动生成页面

**组件库**

1. 规范，样式、前缀、git 提交、eslint、prettier
2. 构建，dist、example、dumi、webapp；gulp 读取 example 和 src 进行转换，预发布文件夹固定前缀拷贝到 miniprogram_npm
3. 小程序转 webapp，weweb、m2w
4. CI/CD 流程，主分支提交触发智研构建，打包源码，在线文档和 webapp，webapp 通过 dumi headScript iframe 嵌入
5. 发布流程，run 发布脚本，首先执行构建任务、自动执行 git commit & tnpm 发布，登录小程序后台完成示例小程序发布

**dumi 原理**

1. 基于 umi 生态的一个支持约定式路由，默认主题的 React 模板，收集 markdown 文件进行解析嵌入到路由页面
2. 底层用的是 umi 生态的 father 进行构建，markdown 解析使用的是 remark-parse，读取 markdown 字符流解析为 html 字符串，然后通过 dangerouslySetInnerHTML 嵌入到页面

**m2w 原理**

1. 准备一个模板项目包含首页和 service 和 webview 引擎
2. 读取 app.json 的 usingComponents，生成组件路由
3. 组件的 wxml、wxss 使用 miniprogram-compiler 转成 jsString 嵌入到 webview
4. js 使用 babel 转为 cjs 模块嵌入
5. 启动 koa 服务器将打包好的静态文件部署

**小程序原理**

发展历史：WeixinJSBridge、JS-SDK、离线缓存、小程序

背景：微信爆火后，微信中的 Webview 网页逐渐成为移动 Web 的一个重要入口

1. 当时微信内部有一个叫 WeixinJSBridge 的库提供一些 API 给腾讯内部的一些业务使用，比如调用微信原生组件浏览图片；后来很多外部开发者发现之后，依葫芦画瓢地使用了，逐渐成为微信中网页的事实标准
2. 于是 2015 年初，微信发布了一整套网页开发工具包叫 JS-SDK，开放了拍摄、支付、地图、分享等几十个 API；JS-SDK 解决了移动网页能力不足的问题，但没有解决体验问题，最常见的是当时用户访问网页前都会有一个白屏过程
3. 针对这个问题微信团队设计了一个 JS-SDK 增强版本，引入了微信 Web 资源离线存储（类似于 HTML5 的 Application Cache，通过创建 manifest 支持离线缓存），借助微信的能力，支持直接从微信本地加载 Web 资源而不再需要从服务端拉取，从而减少网页加载时间；离线缓存能够解决一些问题，但是对于复杂的页面尤其是加载了大量 CSS 或者 JavaScript 文件的页面，白屏依旧存在并且缺少操作反馈，比如页面切换生硬、点击右迟滞感；
4. 鉴于上面 JS-SDK 暴露的一些问题，微信重新设计了一个新的系统支持更快的加载、更强大的能力、媲美原生的体验，就是我们熟知的小程序

小程序与网页开发的区别，

1. 网页中渲染进程和 JavaScript 引擎是互斥的，小程序中两者是分开的，运行在不同的逻辑层和渲染层
2. 小程序逻辑层运行在 JSCore 中，缺少 DOM 和 BOM 的一些 API，所以一些常见的 JQuery、Zepto 等库是无法在小程序中运行的，JSCore 与 NodeJS 环境也不尽相同，所以一些 NPM 包在小程序中也是无法运行的
3. 网页开发面对的是各大浏览器，小程序开发面对的是两大操作系统的微信客户端以及开发者工具

小程序架构，

1. 双线程模型，通过微信客户端作为桥梁，链接 JSCore 逻辑层和 Webview 渲染层
2. 框架的核心是一个响应的数据绑定系统，类似于 Web Work 与浏览器通信，只需要在逻辑层修改数据，视图层就会做相应的更新

setData 原理，

1. 逻辑层虚拟 DOM 树遍历和更新，触发组件生命周期和 observer 等
2. 将变化数据从逻辑层传输到视图层，跨线程通信，需要进行序列反序列化，IOS 上是通过 evaluateJavascript 实现，还会有额外 JS 脚本解析和执行的耗时
3. 视图层虚拟 DOM 树更新，真实 DOM 元素更新并触发页面渲染更新

setData 优化，

1. 非渲染相关数据不建议放 data 中
2. 控制数据量大小，连续调用合并为一次，每次只传变化的数据，如只 set 数组中的某一项或对象的某个属性
3. 页面切换后台后的更新操作，尽量避免后延迟到 onShow 执行，逻辑层是单线程，后台页面会抢占前台运行资源
4. 组件化粒度控制，组件的 setData 只会引起当前组件和子组件的更新
